$date
	Sat Jun 06 18:05:29 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_Datapath $end
$var reg 1 ! clk $end
$scope module tb $end
$var wire 1 ! clock $end
$var wire 32 " write_data [31:0] $end
$var wire 5 # shamt [4:0] $end
$var wire 32 $ rt_content [31:0] $end
$var wire 5 % rt [4:0] $end
$var wire 32 & rs_content [31:0] $end
$var wire 5 ' rs [4:0] $end
$var wire 5 ( rd [4:0] $end
$var wire 6 ) opcode [5:0] $end
$var wire 32 * memory_read_data [31:0] $end
$var wire 32 + instruction [31:0] $end
$var wire 32 , immediate [31:0] $end
$var wire 6 - funct [5:0] $end
$var wire 1 . flag $end
$var wire 26 / address [25:0] $end
$var wire 1 0 RegWrite $end
$var wire 1 1 RegRead $end
$var wire 1 2 RegDst $end
$var wire 1 3 PCSrc $end
$var wire 1 4 MemWrite $end
$var wire 1 5 MemToReg $end
$var wire 1 6 MemRead $end
$var wire 1 7 BranchNE $end
$var wire 1 8 Branch $end
$var wire 2 9 ALUop [1:0] $end
$var wire 1 : ALUSrc $end
$var wire 4 ; ALUInput [3:0] $end
$var reg 32 < PC [31:0] $end
$scope module p1 $end
$var wire 32 = program_counter [31:0] $end
$var reg 32 > instruction [31:0] $end
$upscope $end
$scope module p2 $end
$var wire 32 ? instruction [31:0] $end
$var wire 32 @ p_count [31:0] $end
$var wire 6 A opcode [5:0] $end
$var reg 26 B address [25:0] $end
$var reg 32 C extended_immediate [31:0] $end
$var reg 6 D funct [5:0] $end
$var reg 5 E rd [4:0] $end
$var reg 5 F rs [4:0] $end
$var reg 5 G rt [4:0] $end
$var reg 5 H shamt [4:0] $end
$upscope $end
$scope module p3 $end
$var wire 6 I funct [5:0] $end
$var wire 2 J ALUop [1:0] $end
$var reg 4 K ALUInput [3:0] $end
$upscope $end
$scope module p4 $end
$var wire 4 L ALUInput [3:0] $end
$var wire 32 M immediate [31:0] $end
$var wire 5 N rs [4:0] $end
$var wire 5 O rt [4:0] $end
$var wire 32 P rt_content [31:0] $end
$var wire 32 Q rs_content [31:0] $end
$var wire 1 : ALUSrc $end
$var reg 32 R ALU_result [31:0] $end
$var reg 1 . flag $end
$var reg 32 S signed_rs [31:0] $end
$var reg 32 T signed_rt [31:0] $end
$upscope $end
$scope module p5 $end
$var wire 32 U address [31:0] $end
$var wire 6 V opcode [5:0] $end
$var wire 32 W write_data [31:0] $end
$var wire 1 4 MemWrite $end
$var wire 1 6 MemRead $end
$var reg 32 X read_data [31:0] $end
$upscope $end
$scope module p6 $end
$var wire 1 ! clk $end
$var wire 6 Y opcode [5:0] $end
$var wire 5 Z rd [4:0] $end
$var wire 32 [ read_mem_data [31:0] $end
$var wire 5 \ rs [4:0] $end
$var wire 5 ] rt [4:0] $end
$var wire 32 ^ write_data [31:0] $end
$var wire 1 0 RegWrite $end
$var wire 1 1 RegRead $end
$var wire 1 2 RegDst $end
$var wire 1 5 MemToReg $end
$var reg 32 _ read_data_1 [31:0] $end
$var reg 32 ` read_data_2 [31:0] $end
$upscope $end
$scope module p7 $end
$var wire 6 a funct [5:0] $end
$var wire 6 b opcode [5:0] $end
$var reg 1 : ALUSrc $end
$var reg 2 c ALUop [1:0] $end
$var reg 1 8 Branch $end
$var reg 1 7 BranchNE $end
$var reg 1 6 MemRead $end
$var reg 1 5 MemToReg $end
$var reg 1 4 MemWrite $end
$var reg 1 3 PCSrc $end
$var reg 1 2 RegDst $end
$var reg 1 1 RegRead $end
$var reg 1 0 RegWrite $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 c
b100011 b
bx a
b0 `
b0 _
b1 ^
b0 ]
b1 \
b111 [
bx Z
b100011 Y
b111 X
b0 W
b100011 V
b1 U
b1 T
b0 S
b1 R
b0 Q
b0 P
b0 O
b1 N
b1 M
b10 L
b10 K
b0 J
bx I
bx H
b0 G
b1 F
bx E
bx D
b1 C
bx B
b100011 A
b0 @
b10001100001000000000000000000001 ?
b10001100001000000000000000000001 >
b0 =
b0 <
b10 ;
1:
b0 9
08
07
16
15
04
03
02
11
10
bx /
x.
bx -
b1 ,
b10001100001000000000000000000001 +
b111 *
b100011 )
bx (
b1 '
b0 &
b0 %
b0 $
bx #
b1 "
0!
$end
#100
05
0:
01
00
06
bx ,
bx C
bx M
bx '
bx F
bx N
bx \
bx %
bx G
bx O
bx ]
bx )
bx A
bx V
bx Y
bx b
bx +
bx >
bx ?
b1 <
b1 =
b1 @
1!
#200
0!
#300
b10 <
b10 =
b10 @
1!
#400
0!
#500
b11 <
b11 =
b11 @
1!
#600
0!
#700
b100 <
b100 =
b100 @
1!
#800
0!
#900
b101 <
b101 =
b101 @
1!
#1000
0!
#1100
b110 <
b110 =
b110 @
1!
#1200
0!
#1300
b111 <
b111 =
b111 @
1!
#1400
0!
#1500
b1000 <
b1000 =
b1000 @
1!
#1600
0!
#1700
b1001 <
b1001 =
b1001 @
1!
#1800
0!
#1900
b1010 <
b1010 =
b1010 @
1!
#2000
0!
#2100
b1011 <
b1011 =
b1011 @
1!
#2200
0!
#2300
b1100 <
b1100 =
b1100 @
1!
#2400
0!
#2500
b1101 <
b1101 =
b1101 @
1!
#2600
0!
#2700
b1110 <
b1110 =
b1110 @
1!
#2800
0!
#2900
b1111 <
b1111 =
b1111 @
1!
#3000
0!
#3100
b10000 <
b10000 =
b10000 @
1!
#3200
0!
#3300
b10001 <
b10001 =
b10001 @
1!
#3400
0!
#3500
b10010 <
b10010 =
b10010 @
1!
#3600
0!
#3700
b10011 <
b10011 =
b10011 @
1!
#3800
0!
#3900
b10100 <
b10100 =
b10100 @
1!
#4000
0!
#4100
b10101 <
b10101 =
b10101 @
1!
#4200
0!
#4300
b10110 <
b10110 =
b10110 @
1!
#4400
0!
#4500
b10111 <
b10111 =
b10111 @
1!
#4600
0!
#4700
b11000 <
b11000 =
b11000 @
1!
#4800
0!
#4900
b11001 <
b11001 =
b11001 @
1!
#5000
0!
#5100
b11010 <
b11010 =
b11010 @
1!
#5200
0!
#5300
b11011 <
b11011 =
b11011 @
1!
#5400
0!
#5500
b11100 <
b11100 =
b11100 @
1!
#5600
0!
#5700
b11101 <
b11101 =
b11101 @
1!
#5800
0!
#5900
b11110 <
b11110 =
b11110 @
1!
#6000
0!
#6100
b11111 <
b11111 =
b11111 @
1!
#6200
0!
#6300
b100000 <
b100000 =
b100000 @
1!
#6400
0!
#6500
b100001 <
b100001 =
b100001 @
1!
#6600
0!
#6700
b100010 <
b100010 =
b100010 @
1!
#6800
0!
#6900
b100011 <
b100011 =
b100011 @
1!
#7000
0!
#7100
b100100 <
b100100 =
b100100 @
1!
#7200
0!
#7300
b100101 <
b100101 =
b100101 @
1!
#7400
0!
#7500
b100110 <
b100110 =
b100110 @
1!
#7600
0!
#7700
b100111 <
b100111 =
b100111 @
1!
#7800
0!
#7900
b101000 <
b101000 =
b101000 @
1!
#7990
