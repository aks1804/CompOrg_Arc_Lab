$date
	Sun May 24 15:10:34 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_RType $end
$var reg 1 ! clk $end
$scope module tb $end
$var wire 1 ! clock $end
$var wire 32 " write_data [31:0] $end
$var wire 5 # shamt [4:0] $end
$var wire 32 $ rt_content [31:0] $end
$var wire 5 % rt [4:0] $end
$var wire 32 & rs_content [31:0] $end
$var wire 5 ' rs [4:0] $end
$var wire 5 ( rd [4:0] $end
$var wire 6 ) opcode [5:0] $end
$var wire 32 * memory_read_data [31:0] $end
$var wire 32 + instruction [31:0] $end
$var wire 32 , immediate [31:0] $end
$var wire 6 - funct [5:0] $end
$var wire 1 . flag $end
$var wire 26 / address [25:0] $end
$var wire 4 0 ALUInput [3:0] $end
$var reg 1 1 ALUSrc $end
$var reg 2 2 ALUop [1:0] $end
$var reg 1 3 MemRead $end
$var reg 1 4 MemToReg $end
$var reg 1 5 MemWrite $end
$var reg 32 6 PC [31:0] $end
$var reg 1 7 PCSrc $end
$var reg 1 8 RegDst $end
$var reg 1 9 RegRead $end
$var reg 1 : RegWrite $end
$var reg 1 ; branch_signal $end
$scope module p1 $end
$var wire 32 < program_counter [31:0] $end
$var reg 32 = instruction [31:0] $end
$upscope $end
$scope module p2 $end
$var wire 32 > instruction [31:0] $end
$var wire 32 ? p_count [31:0] $end
$var wire 6 @ opcode [5:0] $end
$var reg 26 A address [25:0] $end
$var reg 32 B extended_immediate [31:0] $end
$var reg 6 C funct [5:0] $end
$var reg 5 D rd [4:0] $end
$var reg 5 E rs [4:0] $end
$var reg 5 F rt [4:0] $end
$var reg 5 G shamt [4:0] $end
$upscope $end
$scope module p3 $end
$var wire 2 H ALUop [1:0] $end
$var wire 6 I funct [5:0] $end
$var reg 4 J ALUInput [3:0] $end
$upscope $end
$scope module p4 $end
$var wire 4 K ALUInput [3:0] $end
$var wire 1 1 ALUSrc $end
$var wire 32 L immediate [31:0] $end
$var wire 5 M rs [4:0] $end
$var wire 5 N rt [4:0] $end
$var wire 32 O rt_content [31:0] $end
$var wire 32 P rs_content [31:0] $end
$var reg 32 Q ALU_result [31:0] $end
$var reg 1 . flag $end
$var reg 32 R signed_rs [31:0] $end
$var reg 32 S signed_rt [31:0] $end
$upscope $end
$scope module p5 $end
$var wire 1 3 MemRead $end
$var wire 1 5 MemWrite $end
$var wire 32 T address [31:0] $end
$var wire 6 U opcode [5:0] $end
$var wire 32 V write_data [31:0] $end
$var reg 32 W read_data [31:0] $end
$upscope $end
$scope module p6 $end
$var wire 1 4 MemToReg $end
$var wire 1 8 RegDst $end
$var wire 1 9 RegRead $end
$var wire 1 : RegWrite $end
$var wire 1 ! clk $end
$var wire 6 X opcode [5:0] $end
$var wire 5 Y rd [4:0] $end
$var wire 32 Z read_mem_data [31:0] $end
$var wire 5 [ rs [4:0] $end
$var wire 5 \ rt [4:0] $end
$var wire 32 ] write_data [31:0] $end
$var reg 32 ^ read_data_1 [31:0] $end
$var reg 32 _ read_data_2 [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100 _
b10 ^
b110 ]
b1 \
b0 [
bx Z
b1001 Y
b0 X
bx W
b100 V
b0 U
b110 T
b100 S
b10 R
b110 Q
b10 P
b100 O
b1 N
b0 M
bx L
b10 K
b10 J
b100000 I
b10 H
b0 G
b1 F
b0 E
b1001 D
b100000 C
bx B
bx A
b0 @
b0 ?
b10100100000100000 >
b10100100000100000 =
b0 <
0;
1:
19
18
07
b0 6
05
04
03
b10 2
01
b10 0
bx /
x.
b100000 -
bx ,
b10100100000100000 +
bx *
b0 )
b1001 (
b0 '
b10 &
b1 %
b100 $
b0 #
b110 "
0!
$end
#100
b1010 "
b1010 Q
b1010 T
b1010 ]
b110 R
b110 &
b110 P
b110 ^
b10 '
b10 E
b10 M
b10 [
b11 (
b11 D
b11 Y
b10000010001100000100000 +
b10000010001100000100000 =
b10000010001100000100000 >
b1 6
b1 <
b1 ?
1!
#200
0!
#300
b10001 "
b10001 Q
b10001 T
b10001 ]
b1111 S
b10 R
b1111 $
b1111 O
b1111 V
b1111 _
b10 &
b10 P
b10 ^
b0 '
b0 E
b0 M
b0 [
b100 %
b100 F
b100 N
b100 \
b110 (
b110 D
b110 Y
b1000011000000100000 +
b1000011000000100000 =
b1000011000000100000 >
b10 6
b10 <
b10 ?
1!
#400
0!
#490
